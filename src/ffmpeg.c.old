#include <libavformat/avformat.h>
#include <libavcodec/avcodec.h>
#include <libswscale/swscale.h>
#include <libavcodec/packet.h>
#include <libavcodec/codec.h>
#include <libavutil/dict.h>

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <emscripten.h>

typedef struct {
    AVCodec* codec;
    AVPacket* packet;
    AVFrame* inputFrame;
    AVStream* avStreamOut;
    AVIOContext* avioContext;
    AVCodecContext* codecCtx;
    AVFormatContext* formatContext;
    struct SwsContext* swsCtx;
    int size;
    unsigned long bytesWritten;
    unsigned long outputSize;
    uint8_t* outputBuffer;
    unsigned long frameCounter;
} ffmpeg_context;

void hexdump(void *ptr, int buflen) {
  unsigned char *buf = (unsigned char*)ptr;
  int i, j;
  for (i=0; i<buflen; i+=16) {
    printf("%06x: ", i);
    for (j=0; j<16; j++)
      if (i+j < buflen)
        printf("%02x ", buf[i+j]);
      else
        printf("   ");
    printf(" ");
    for (j=0; j<16; j++)
      if (i+j < buflen)
        printf("%c", isprint(buf[i+j]) ? buf[i+j] : '.');
    printf("\n");
  }
}

void encode(ffmpeg_context* ctx);

void init_context(ffmpeg_context* ctx, unsigned int width, unsigned int height);
void add_frame(ffmpeg_context* ctx, uint8_t* rgbaData);
void retrieve_video(ffmpeg_context* ctx, uint8_t* outputBuffer);
unsigned long retrieve_video_size(ffmpeg_context* ctx);

int read_packet(void *opaque, uint8_t *buffer, int bufferSize) {
    printf("read_packet\n");
    return bufferSize;
}

int write_packet(void *opaque, uint8_t *buffer, int bufferSize) {
    printf("write_packet: %p %d\n", buffer, bufferSize);
    ffmpeg_context* ctx = (ffmpeg_context*) opaque;

    int index = ctx->bytesWritten;
    ctx->bytesWritten += bufferSize;
    ctx->outputBuffer = av_realloc(ctx->outputBuffer, ctx->bytesWritten);
    memcpy(ctx->outputBuffer, buffer, bufferSize);

    return bufferSize;
}

void init_context(ffmpeg_context* ctx, unsigned int width, unsigned int height) {
    // ctx = (ffmpeg_context*) calloc(1, sizeof(ffmpeg_context));

    printf("ctx = %p\n", ctx);
    ctx->codec = avcodec_find_encoder(AV_CODEC_ID_MPEG2VIDEO);
    ctx->codecCtx = avcodec_alloc_context3(ctx->codec);
    ctx->codecCtx->pix_fmt = AV_PIX_FMT_YUV420P;
    ctx->codecCtx->width = width;
    ctx->codecCtx->height = height;
    ctx->codecCtx->time_base = (AVRational){1, 25};
    ctx->codecCtx->framerate = (AVRational){25, 1};
    ctx->frameCounter = 0;
    ctx->formatContext = avformat_alloc_context();
    ctx->bytesWritten = 0;
    ctx->outputSize = 8192;
    ctx->outputBuffer = av_malloc(ctx->outputSize);
    ctx->avioContext = avio_alloc_context(
        ctx->outputBuffer,
        ctx->outputSize,
        1,
        (void*) ctx,
        NULL,
        &write_packet,
        NULL
    );
    // printf("ctx->avStreamOut %p\n", ctx->avStreamOut);
    // ctx->avioContext = ctx->avStreamOut;
    ctx->formatContext->pb = ctx->avioContext;
    ctx->formatContext->flags = AVFMT_FLAG_CUSTOM_IO;

    int response = avformat_alloc_output_context2(&ctx->formatContext, NULL, NULL, "outfile.mp2");
    printf("avformat_alloc_output_context2 response=%d %s\n", response, av_err2str(response));

    // printf("avformat_open_output %p\n", &ctx->formatContext);
    // int res = avformat_open_output(&ctx->formatContext, "", NULL, NULL);
    // printf("avformat_open_output res = %d, %s\n", res, av_err2str(res));
    // return;

    AVDictionary* opt = NULL;
    av_dict_set(&opt, "preset", "slow", 0);
    av_dict_set(&opt, "no-mbtree", "", 0);
    av_dict_set(&opt, "rc-lookahead", "0", 0);

    if (avcodec_open2(ctx->codecCtx, ctx->codec, &opt) < 0) {
        printf("Error when opening codec\n");

        // return 1;
    }

    ctx->size = ctx->codecCtx->width * ctx->codecCtx->height;

    uint8_t* picture_buf = (uint8_t*) malloc((ctx->size * 3) / 2); /* size for YUV 420 */
    ctx->inputFrame = av_frame_alloc();
    ctx->inputFrame->format = ctx->codecCtx->pix_fmt;
    ctx->inputFrame->width = ctx->codecCtx->width;
    ctx->inputFrame->height = ctx->codecCtx->height;
    ctx->inputFrame->nb_samples = 1;
    ctx->inputFrame->channel_layout = 0;
    ctx->inputFrame->data[0] = picture_buf;
    ctx->inputFrame->data[1] = ctx->inputFrame->data[0] + ctx->size;
    ctx->inputFrame->data[2] = ctx->inputFrame->data[1] + ctx->size / 4;
    ctx->inputFrame->linesize[0] = ctx->codecCtx->width;
    ctx->inputFrame->linesize[1] = ctx->codecCtx->width / 2;
    ctx->inputFrame->linesize[2] = ctx->codecCtx->width / 2;

    printf("ctx->inputFrame = %p\n", ctx->inputFrame);

    // response = ctx->formatContext->oformat->write_header(ctx->formatContext);
    response = avformat_write_header(ctx->formatContext, NULL);
    printf("avformat_write_header response=%d %s\n", response, av_err2str(response));

    response = av_frame_get_buffer(ctx->inputFrame, 1);
    printf("av_frame_get_buffer response=%d %s\n", response, av_err2str(response));
    // if (response != 0) return response;

    ctx->packet = av_packet_alloc();

    ctx->swsCtx = sws_getContext(
        ctx->codecCtx->width,
        ctx->codecCtx->height,
        AV_PIX_FMT_RGBA,
        ctx->codecCtx->width,
        ctx->codecCtx->height,
        AV_PIX_FMT_YUV420P,
        0, 0, 0, 0
    );
    printf("sws_getContext swsCtx=%p\n",ctx->swsCtx);
}

void add_frame(ffmpeg_context* ctx, uint8_t* rgbaData) {
    // printf("ctx = %p rgbaData = %p\n", ctx, rgbaData);
    // printf("ctx->inputFrame = %p\n", ctx->inputFrame);`
    // hexdump(rgbaData, 4 * ctx->codecCtx->width);

    av_init_packet(ctx->packet);
    ctx->packet->data = NULL;
    ctx->packet->size = ctx->size;

    int response = av_frame_make_writable(ctx->inputFrame);
    printf("av_frame_make_writable response=%d %s\n", response, av_err2str(response));

    uint8_t* inputData[1] = { rgbaData };
    int inputLineSize[1] = { 4 * ctx->codecCtx->width };
    printf("inputData %p\n", inputData);
    printf("inputLineSize %p\n", inputLineSize);
    printf("ctx->codecCtx->height %d\n", ctx->codecCtx->height);
    printf("ctx->inputFrame->data %p\n", ctx->inputFrame->data);
    printf("ctx->inputFrame->linesize %d\n", ctx->inputFrame->linesize);

    sws_scale(
        ctx->swsCtx,
        inputData,
        inputLineSize,
        0,
        ctx->codecCtx->height,
        ctx->inputFrame->data,
        ctx->inputFrame->linesize
    );

    ctx->inputFrame->pts = ctx->frameCounter++;

    encode(ctx);
}

unsigned long retrieve_video_size(ffmpeg_context* ctx) {
    return ctx->outputSize;
}

void retrieve_video(ffmpeg_context* ctx, uint8_t* outputBuffer) {
    outputBuffer = ctx->outputBuffer;
}


void encode(ffmpeg_context* ctx) {
        int response = avcodec_send_frame(ctx->codecCtx, ctx->inputFrame);
        printf("avcodec_send_frame response=%d %s\n", response, av_err2str(response));

        while (response >= 0) {
            response = avcodec_receive_packet(ctx->codecCtx, ctx->packet);
            printf("avcodec_receive_packet response=%d %s\n", response, av_err2str(response));

            if (response == AVERROR(EAGAIN) || response == AVERROR_EOF) {
                printf("skipping...\n");
                continue;
                // return;
            } else if (response < 0) {
                printf("other error\n");
                return;
            };

            // Allocate the buffer and write.
            int index = ctx->outputSize;
            ctx->outputSize += ctx->packet->size;
            // ctx->packet->stream_index = 1;
            printf("Writing %d bytes to buffer index %d\n", ctx->packet->size, index);

            if (ctx->outputBuffer) ctx->outputBuffer = realloc(ctx->outputBuffer, ctx->outputSize);
            else ctx->outputBuffer = malloc(ctx->outputSize);

            printf("Writing %d bytes to buffer\n", ctx->packet->size);

            // memcpy(&ctx->outputBuffer[index], ctx->packet->data, ctx->packet->size);
            av_write_frame(ctx->formatContext, ctx->packet);

            av_packet_unref(ctx->packet);

            break;
        }
}
